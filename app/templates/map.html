{% extends 'base.html' %}

{% block content %}
{% include 'sidebar.html' %}

<div class="main-content">
    <div id="map"></div>
    
    <!-- Overlay Elements -->
    <div class="map-overlays">
        <!-- Stats Overlay -->
        <div class="stats-overlay">
            <div class="stat-item">
                <div class="stat-icon">
                    <i class="fas fa-check-circle"></i>
                </div>
                <div class="stat-info">
                    <div class="stat-value" id="completion-rate">0%</div>
                    <div class="stat-label">Completion Rate</div>
                </div>
            </div>
            <div class="stat-item">
                <div class="stat-icon">
                    <i class="fas fa-car"></i>
                </div>
                <div class="stat-info">
                    <div class="stat-value" id="vehicle-stats">0/0</div>
                    <div class="stat-label">Available Vehicles</div>
                </div>
            </div>
            <div class="stat-item">
                <div class="stat-icon">
                    <i class="fas fa-route"></i>
                </div>
                <div class="stat-info">
                    <div class="stat-value" id="total-distance">0 km</div>
                    <div class="stat-label">Total Distance</div>
                </div>
            </div>
            <div class="stat-item">
                <div class="stat-icon">
                    <i class="fas fa-hourglass-half"></i>
                </div>
                <div class="stat-info">
                    <div class="stat-value" id="total-time">0s</div>
                    <div class="stat-label">Total Time</div>
                </div>
            </div>
        </div>

        <!-- Scenario Controls Overlay -->
        <div class="controls-overlay">
            <div class="scenario-controls">
                <select id="scenarioSelect" class="scenario-select">
                    <option value="">Select a scenario...</option>
                </select>
                <button class="run-scenario optimized">
                    <i class="fas fa-play"></i>
                    Run Optimized
                </button>
                <button class="run-scenario naive">
                    <i class="fas fa-play"></i>
                    Run Naive
                </button>
            </div>
        </div>
    </div>
</div>


<!-- SIMULATION COMPLETED POPUP -->
<div id="simulationEndDialog" class="modal">
    <div class="modal-content">
        <div class="modal-icon">
            <i class="fas fa-moon"></i>
        </div>
        <h2>End of Day</h2>
        <p>Your vehicles have served the city well!</p>
        <button onclick="closeSimulationEndDialog()" class="modal-close-btn">
            <i class="fas fa-check"></i> Close
        </button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script src="{{ url_for('static', filename='js/leaflet-heat.js') }}"></script>
<style>
    .custom-marker i {
        font-size: 14px;
        color: white;
    }
    .legend {
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        font-family: 'Inter', sans-serif;
        border: 1px solid rgba(0, 0, 0, 0.05);
    }
    .legend h4 {
        font-weight: 500;
        font-size: 14px;
        margin-bottom: 12px;
        color: #1a1a1a;
    }
    .legend-item {
        display: flex;
        align-items: center;
        margin: 8px 0;
        font-size: 12px;
        color: #4a5568;
    }
    .legend i {
        margin-right: 8px;
        width: 20px;
        text-align: center;
    }
    #map {
        width: 100% !important;
        height: 100vh !important;
    }

    .custom-marker {
        transition: all 0.3s ease;
    }
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .modal.show {
        opacity: 1;
        visibility: visible;
    }
    
    .modal-content {
        background-color: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        max-width: 400px;
        transform: scale(0.95);
        opacity: 0;
        transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .modal.show .modal-content {
        transform: scale(1);
        opacity: 1;
    }
    
    @keyframes modalFadeIn {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    .modal-icon {
        font-size: 40px;
        color: #4a90e2;
        margin-bottom: 20px;
    }
    
    .modal-content h2 {
        color: #333;
        margin-bottom: 15px;
        font-size: 24px;
    }
    
    .modal-content p {
        color: #666;
        margin-bottom: 25px;
        line-height: 1.5;
    }
    
    .modal-close-btn {
        background-color: #4a90e2;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
    }
    
    .modal-close-btn:hover {
        background-color: #357abd;
    }

    .scenario-controls {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .run-scenario {
        padding: 8px 16px;
        border-radius: 5px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.3s ease;
        background-color: #E20074;
        color: white;
    }

    .run-scenario.running {
        display: none;
    }

    .run-scenario.running.active {
        display: flex;
        background-color: #E20074;
    }

    .run-scenario:hover {
        opacity: 0.9;
    }

    .stats-overlay {
        display: flex;
        gap: 20px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .stat-item {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .stat-icon {
        width: 40px;
        height: 40px;
        background-color: #E20074;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .stat-icon i {
        color: white;
        font-size: 18px;
    }

    .stat-info {
        display: flex;
        flex-direction: column;
    }

    .stat-value {
        font-size: 18px;
        font-weight: 600;
        color: #333;
    }

    .stat-label {
        font-size: 12px;
        color: #666;
    }

    .leaflet-heatmap-layer {
        transition: opacity 0.5s ease-in-out !important;
    }
</style>

<script>
// Constants
const MUNICH_CENTER = [48.137154, 11.576124]; // [lat, lng]

const MUNICH_BOUNDS = {
    lat: { min: 48.0, max: 48.25 },
    lng: { min: 11.36, max: 11.79 }
};

const MAX_BOUNDS = [
    [MUNICH_BOUNDS.lat.min, MUNICH_BOUNDS.lng.min],
    [MUNICH_BOUNDS.lat.max, MUNICH_BOUNDS.lng.max]
];

// Initialize map
const map = L.map('map', {
    center: MUNICH_CENTER,
    zoom: 12,
    maxBounds: MAX_BOUNDS,
    minZoom: 11,
    zoomControl: false,
    attributionControl: false
});

// Add map tiles
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
}).addTo(map);

// Add zoom control
L.control.zoom({
    position: 'bottomright'
}).addTo(map);

// Global variables
let currentScenarioId = null;
let simulationRunning = false;
let updateInterval;
let lastUpdateTime = Date.now();
let currentMarkers = new Map();
let currentLines = new Map();

function updateLastUpdateTime() {
    const timeDiff = Math.round((Date.now() - lastUpdateTime) / 1000);
    const timeElement = document.querySelector('.stats-overlay .stat-item:last-child .stat-value');
    if (timeElement) {
        timeElement.textContent = timeDiff < 60 ? `${timeDiff}s ago` : 'Live';
    }
}

// Function to fetch the initial state of a scenario from the template endpoint
async function fetchScenarioTemplate(scenarioId) {
    try {
        const response = await fetch(`/scenario_template/${scenarioId}`);
        if (!response.ok) throw new Error('Failed to fetch scenario template');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching scenario template:', error);
        return null;
    }
}

// Event listener for scenario selection change
async function handleScenarioSelection(event) {
    const scenarioId = event.target.value;

    // Clear the map first
    clearMap();

    if (!scenarioId) {
        console.log('No scenario selected');
        return;
    }

    // Fetch the scenario template data
    const scenarioData = await fetchScenarioTemplate(scenarioId);

    if (scenarioData) {
        // Update the map and stats with the template data
        updateMap(scenarioData, true);
        updateStats(scenarioData);
    } else {
        console.error('No data available for the selected scenario');
    }
}

// Add the event listener to the scenario selection dropdown
document.addEventListener('DOMContentLoaded', () => {
    const scenarioSelect = document.getElementById('scenarioSelect');
    scenarioSelect.addEventListener('change', handleScenarioSelection);
});

function clearMap() {
    // Clear all customer and vehicle markers
    if (currentMarkers.size > 0) {
        currentMarkers.forEach(marker => {
            if (map.hasLayer(marker)) {
                map.removeLayer(marker);
            }
        });
        currentMarkers.clear();
    }

    // Clear all lines and destination markers
    if (currentLines.size > 0) {
        currentLines.forEach(lineObjects => {
            if (map.hasLayer(lineObjects.line)) {
                map.removeLayer(lineObjects.line);
            }
            if (map.hasLayer(lineObjects.marker)) {
                map.removeLayer(lineObjects.marker);
            }
        });
        currentLines.clear();
    }

    console.log('Cleared all markers and lines from the map.');
}

function showSimulationEndDialog() {
    getScenarioState().then(finalState => {
        if (finalState) {
            updateMap(finalState);
            updateStats(finalState);
        }
        
        setTimeout(() => {
            const modal = document.getElementById('simulationEndDialog');
            modal.style.display = 'flex';
            // Force a reflow
            modal.offsetHeight;
            modal.classList.add('show');
            
            simulationRunning = false;
            currentScenarioId = null;
            updateUI(false);
            stopUpdates();
            
            // Clear map after stopping updates
            clearMap();
            
            // Add heatmap with fade
            map.addLayer(heatLayer);
            const heatmapCanvas = document.querySelector('.leaflet-heatmap-layer');
            if (heatmapCanvas) {
                heatmapCanvas.style.opacity = '0';
                heatmapCanvas.offsetHeight;
                heatmapCanvas.style.opacity = '1';
            }
        }, 1000);
    });
}

function closeSimulationEndDialog() {
    const modal = document.getElementById('simulationEndDialog');
    modal.classList.remove('show');
    setTimeout(() => {
        modal.style.display = 'none';
    }, 300); // Match the transition duration
}


function getPosition(coordX, coordY) { //smazat
    // Handle null or undefined coordinates
    if (coordX == null || coordY == null) {
        console.warn('Null coordinates received:', { coordX, coordY });
        return MUNICH_CENTER; // Return default position
    }

    const lat = Number(coordX);
    const lng = Number(coordY);

    // Check if coordinates are valid numbers
    if (isNaN(lat) || isNaN(lng)) {
        console.warn('Invalid coordinates received:', { coordX, coordY });
        return MUNICH_CENTER;
    }

    // Ensure coordinates stay within bounds
    const boundedLat = Math.max(MUNICH_BOUNDS.lat.min, Math.min(MUNICH_BOUNDS.lat.max, lat));
    const boundedLng = Math.max(MUNICH_BOUNDS.lng.min, Math.min(MUNICH_BOUNDS.lng.max, lng));

    return [boundedLat, boundedLng];
}

function updateMap(data, ignoreFlagington=false) {
    if (!simulationRunning && !ignoreFlagington) {
        console.log('Update is skipped, simulation is not running.');
        return;
    }

    if (!data?.vehicles || !data?.customers) {
        console.error('Invalid data structure:', data);
        return;
    }

    // Update customers
    data.customers.forEach(customer => {
        const markerId = `customer-${customer.id}`;
        const lineId = `line-${customer.id}`;

        if (customer.awaitingService) {
            const [lat, lng] = getPosition(customer.coordX, customer.coordY);
            const [destLat, destLng] = getPosition(customer.destinationX, customer.destinationY);

            // Handle the line and destination marker
            if (!currentLines.has(lineId)) {
                // Create new line
                const polyline = L.polyline(
                    [[lat, lng], [destLat, destLng]],
                    {
                        color: '#FF5722',
                        weight: 2,
                        opacity: 0.6,
                        dashArray: '5, 10'
                    }
                ).addTo(map);

                // Create destination marker
                const destinationMarker = L.marker([destLat, destLng], {
                    icon: L.divIcon({
                        html: `<div style="
                            background-color: #FF5722;
                            width: 20px;
                            height: 20px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            box-shadow: 0 0 10px rgba(0,0,0,0.2);
                        "><i class="fas fa-flag" style="font-size: 10px; color: white;"></i></div>`,
                        className: 'custom-marker'
                    })
                }).addTo(map);

                destinationMarker.bindPopup(`
                    <div style="font-family: 'Inter', sans-serif; font-size: 12px;">
                        <strong style="color: #1a1a1a;">Destination</strong><br>
                        <span style="color: #666;">Customer ${customer.id}</span>
                    </div>
                `);

                currentLines.set(lineId, {
                    line: polyline,
                    marker: destinationMarker
                });
            } else {
                // Update existing line and marker positions
                const lineObjects = currentLines.get(lineId);
                lineObjects.line.setLatLngs([[lat, lng], [destLat, destLng]]);
                lineObjects.marker.setLatLng([destLat, destLng]);
            }

            // Handle the customer marker
            if (!currentMarkers.has(markerId)) {
                const customerMarker = L.marker([lat, lng], {
                    icon: L.divIcon({
                        html: `<div style="
                            background-color: #FFC107;
                            width: 30px;
                            height: 30px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            box-shadow: 0 0 15px rgba(0,0,0,0.2);
                        "><i class="fas fa-user"></i></div>`,
                        className: 'custom-marker'
                    })
                }).addTo(map);

                customerMarker.bindPopup(`
                    <div style="font-family: 'Inter', sans-serif; font-size: 12px;">
                        <strong style="color: #1a1a1a;">Customer ${customer.id}</strong><br>
                        <span style="color: #FFC107;">Waiting for pickup</span><br>
                        <span style="color: #666;">Position: [${lat.toFixed(6)}, ${lng.toFixed(6)}]</span>
                    </div>
                `);

                currentMarkers.set(markerId, customerMarker);
            } else {
                currentMarkers.get(markerId).setLatLng([lat, lng]);
            }
        } else {
            // Remove customer marker if not awaiting service
            if (currentMarkers.has(markerId)) {
                map.removeLayer(currentMarkers.get(markerId));
                currentMarkers.delete(markerId);
            }

            // Remove line and destination marker
            if (currentLines.has(lineId)) {
                const lineObjects = currentLines.get(lineId);
                map.removeLayer(lineObjects.line);
                map.removeLayer(lineObjects.marker);
                currentLines.delete(lineId);
            }
        }
    });

    // Identify busy vehicles
    const busyVehicleIds = new Set();
    data.vehicles.forEach(vehicle => {
        data.customers.forEach(customer => {
            if (!customer.awaitingService &&
                vehicle.coordX === customer.coordX &&
                vehicle.coordY === customer.coordY) {
                busyVehicleIds.add(vehicle.id);
            }
        });
    });

    // Update vehicles
    data.vehicles.forEach(vehicle => {
        let lat = vehicle.coordX;
        let lng = vehicle.coordY;

        const [boundedLat, boundedLng] = getPosition(lat, lng);
        const isOccupied = busyVehicleIds.has(vehicle.id);

        // Handle assignment line
        const assignmentLineId = `assignment-${vehicle.id}`;
        if (vehicle.customerId) {
            const assignedCustomer = data.customers.find(c => c.id === vehicle.customerId && c.awaitingService);
            if (assignedCustomer) {
                const [customerLat, customerLng] = getPosition(assignedCustomer.coordX, assignedCustomer.coordY);
                
                if (!currentLines.has(assignmentLineId)) {
                    const assignmentLine = L.polyline(
                        [[boundedLat, boundedLng], [customerLat, customerLng]],
                        {
                            color: '#4CAF50',
                            weight: 2,
                            opacity: 0.8
                        }
                    ).addTo(map);
                    currentLines.set(assignmentLineId, { line: assignmentLine });
                } else {
                    const line = currentLines.get(assignmentLineId).line;
                    line.setLatLngs([
                        [boundedLat, boundedLng],
                        [customerLat, customerLng]
                    ]);
                }
            } else {
                if (currentLines.has(assignmentLineId)) {
                    map.removeLayer(currentLines.get(assignmentLineId).line);
                    currentLines.delete(assignmentLineId);
                }
            }
        } else {
            if (currentLines.has(assignmentLineId)) {
                map.removeLayer(currentLines.get(assignmentLineId).line);
                currentLines.delete(assignmentLineId);
            }
        }

        // Handle vehicle marker
        const markerId = `vehicle-${vehicle.id}`;
        if (!currentMarkers.has(markerId)) {
            const vehicleMarker = L.marker([boundedLat, boundedLng], {
                icon: L.divIcon({
                    html: `<div style="
                        background-color: #4CAF50;
                        width: 36px;
                        height: 36px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        box-shadow: 0 0 20px rgba(0,0,0,0.2);
                    "><i class="fas fa-car-side"></i></div>`,
                    className: 'custom-marker'
                })
            }).addTo(map);

            vehicleMarker.bindPopup(`
                <div style="font-family: 'Inter', sans-serif; font-size: 12px;">
                    <strong style="color: #1a1a1a;">Vehicle ${vehicle.id}</strong><br>
                </div>
            `);

            currentMarkers.set(markerId, vehicleMarker);
        } else {
            const marker = currentMarkers.get(markerId);
            marker.setLatLng([boundedLat, boundedLng]);

            marker.setIcon(L.divIcon({
                html: `<div style="
                    background-color: #4CAF50;
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 0 20px rgba(0,0,0,0.2);
                "><i class="fas fa-car-side"></i></div>`,
                className: 'custom-marker'
            }));

            marker.getPopup().setContent(`
                <div style="font-family: 'Inter', sans-serif; font-size: 12px;">
                    <strong style="color: #1a1a1a;">Vehicle ${vehicle.id}</strong><br>
                </div>
            `);
        }
    });
}

function updateStats(data) {
    if (!data?.metadata?.metadata?.realtime_kpis) return;

    const metadata = data.metadata.metadata;
    const realtimeKpis = metadata.realtime_kpis;

    // Update completion rate
    const completionRate = document.getElementById('completion-rate');
    if (completionRate) {
        completionRate.textContent = `${(realtimeKpis.completion_rate * 100 || 0).toFixed(1)}%`;
    }

    // Update vehicle stats
    const vehicleStats = document.getElementById('vehicle-stats');
    if (vehicleStats) {
        const availableVehicles = realtimeKpis.number_of_available_vehicles || 0;
        const takenVehicles = realtimeKpis.number_of_taken_vehicles || 0;
        vehicleStats.textContent = `${availableVehicles}/${availableVehicles + takenVehicles}`;
    }

    // Update total distance
    const totalDistance = document.getElementById('total-distance');
    if (totalDistance) {
        const distance = realtimeKpis.total_travel_distance || 0;
        totalDistance.textContent = `${(distance / 1000).toFixed(1)} km`;
    }

    // Update total time
    const totalTime = document.getElementById('total-time');
    if (totalTime) {
        const time = realtimeKpis.total_travel_time || 0;
        totalTime.textContent = `${Math.round(time)}s`;
    }
}

function startUpdates() {
    console.log('Starting periodic updates');
    updateInterval = setInterval(async () => {
        console.log('Fetching update...');
        const state = await getScenarioState();
        if (state) {
            updateMap(state);
            updateStats(state);
            console.log(state);
            console.log("--------------------------------");
        }
    }, 300);
}

function stopUpdates() {
    console.log('Stopping updates');
    if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
    }
}

function updateUI(running) {
    const optimizedButton = document.querySelector('.run-scenario.optimized');
    const naiveButton = document.querySelector('.run-scenario.naive');
    
    if (running) {
        // Determine which button was clicked and make it the active stop button
        const activeButton = document.activeElement.classList.contains('optimized') ? optimizedButton : naiveButton;
        const inactiveButton = activeButton === optimizedButton ? naiveButton : optimizedButton;
        
        activeButton.innerHTML = `<i class="fas fa-stop"></i> Stop`;
        activeButton.classList.add('running', 'active');
        inactiveButton.classList.remove('running');
    } else {
        optimizedButton.innerHTML = `<i class="fas fa-play"></i> Run Optimized`;
        naiveButton.innerHTML = `<i class="fas fa-play"></i> Run Naive`;
        optimizedButton.classList.remove('running');
        naiveButton.classList.remove('running');
    }
}

// Add the legend
const legend = L.control({ position: 'bottomleft' });
legend.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'legend');
    div.innerHTML = `
        <h4>Fleet Status</h4>
        <div class="legend-item">
            <i class="fas fa-user" style="color: #FFC107;"></i>
            <span>Waiting Customer</span>
        </div>
        <div class="legend-item">
            <i class="fas fa-car-side" style="color: #4CAF50;"></i>
            <span>Available Vehicle</span>
        </div>
        <div class="legend-item">
            <i class="fas fa-flag" style="color: #FF5722;"></i>
            <span>Customer Destination</span>
        </div>
        <div class="legend-item">
            <div style="
                width: 20px;
                height: 20px;
                background: linear-gradient(to right, #87CEEB, #4CAF50, #FFC107, #FF5722, #E20074);
                display: inline-block;
                margin-right: 8px;
                border-radius: 3px;
            "></div>
            <span>Demand Heatmap</span>
        </div>
    `;
    return div;
};
legend.addTo(map);

// Add new functions for scenario handling
async function loadScenarios() {
    try {
        const response = await fetch('/scenarios');
        const scenarios = await response.json();
        
        const select = document.getElementById('scenarioSelect');
        select.innerHTML = '<option value="">Select a scenario...</option>';
        
        scenarios.forEach(scenario => {
            const option = document.createElement('option');
            option.value = scenario.id;
            option.textContent = `Scenario ${scenario.id}`;
            select.appendChild(option);
        });
    } catch (error) {
        console.error('Failed to load scenarios:', error);
    }
}

async function runScenario(scenarioId, algorithm = 'optimized') {
    try {
        const response = await fetch(`/run/${scenarioId}?algorithm=${algorithm}`, {
            method: 'POST'
        });
        
        if (!response.ok) throw new Error('Failed to start scenario');
        
        simulationRunning = true;
        currentScenarioId = scenarioId;
        updateUI(true);
        startUpdates();
        
        // Fade out heatmap
        const heatmapCanvas = document.querySelector('.leaflet-heatmap-layer');
        if (heatmapCanvas) {
            heatmapCanvas.style.opacity = '0';
            setTimeout(() => {
                map.removeLayer(heatLayer);
            }, 500); // Remove after fade completes
        }
        
    } catch (error) {
        console.error('Error running scenario:', error);
    }
}

async function stopScenario() {
    try {
        if (!currentScenarioId) return;
        
        const response = await fetch(`/stop/${currentScenarioId}`, {
            method: 'POST'
        });
        
        if (!response.ok) throw new Error('Failed to stop scenario');
        
        simulationRunning = false;
        currentScenarioId = null;
        updateUI(false);
        stopUpdates();
        clearMap();
        
        // Add heatmap with fade in
        map.addLayer(heatLayer);
        const heatmapCanvas = document.querySelector('.leaflet-heatmap-layer');
        if (heatmapCanvas) {
            heatmapCanvas.style.opacity = '0';
            // Force a reflow
            heatmapCanvas.offsetHeight;
            // Fade in
            heatmapCanvas.style.opacity = '1';
        }
        
    } catch (error) {
        console.error('Error stopping scenario:', error);
    }
}

async function getScenarioState() {
    try {
        if (!currentScenarioId) return null;
        
        const response = await fetch(`/scenario/${currentScenarioId}`);
        if (!response.ok) throw new Error('Failed to get scenario state');
        
        const data = await response.json();
        
        // Check if simulation has effectively completed
        if (data.status === "COMPLETED" || 
            (data?.metadata?.metadata?.realtime_kpis?.completion_rate === 1 && 
             data?.metadata?.metadata?.realtime_kpis?.number_of_waiting_customers === 0)) {
            showSimulationEndDialog();
        }
        
        return data;
    } catch (error) {
        console.error('Error getting scenario state:', error);
        return null;
    }
}

// Add event listeners
document.addEventListener('DOMContentLoaded', () => {
    loadScenarios();
    
    const optimizedButton = document.querySelector('.run-scenario.optimized');
    const naiveButton = document.querySelector('.run-scenario.naive');
    
    async function handleRunClick(algorithm) {
        const scenarioId = document.getElementById('scenarioSelect').value;
        if (!scenarioId) {
            alert('Please select a scenario first');
            return;
        }
        
        if (simulationRunning) {
            await stopScenario();
        } else {
            await runScenario(scenarioId, algorithm);
        }
    }
    
    optimizedButton.addEventListener('click', () => handleRunClick('optimized'));
    naiveButton.addEventListener('click', () => handleRunClick('naive'));
});

const HEATMAP_POINTS = [
    // City Center (Marienplatz) - High intensity core
    [48.137154, 11.576124, 1.0], // Center point
    [48.136154, 11.575124, 0.95],
    [48.138154, 11.577124, 0.95],
    [48.137154, 11.577124, 0.9],
    [48.136154, 11.576124, 0.9],
    // Extended city center coverage
    [48.135154, 11.574124, 0.8],
    [48.139154, 11.578124, 0.8],
    [48.137154, 11.573124, 0.8],
    [48.138154, 11.579124, 0.8],
    [48.134154, 11.575124, 0.7],
    [48.140154, 11.577124, 0.7],
    // Wide area coverage
    [48.133154, 11.573124, 0.6],
    [48.141154, 11.579124, 0.6],
    [48.137154, 11.571124, 0.6],
    [48.138154, 11.581124, 0.6],
    [48.132154, 11.574124, 0.5],
    [48.142154, 11.578124, 0.5],
    
    // Olympiapark area - Large high-intensity zone
    [48.175626, 11.551809, 0.9], // Center point
    [48.174626, 11.550809, 0.85],
    [48.176626, 11.552809, 0.85],
    [48.175626, 11.552809, 0.8],
    [48.174626, 11.551809, 0.8],
    // Extended Olympic area
    [48.173626, 11.549809, 0.7],
    [48.177626, 11.553809, 0.7],
    [48.175626, 11.554809, 0.7],
    [48.172626, 11.550809, 0.6],
    [48.178626, 11.552809, 0.6],
    // Wide area coverage
    [48.171626, 11.548809, 0.5],
    [48.179626, 11.554809, 0.5],
    [48.175626, 11.556809, 0.5],
    [48.170626, 11.549809, 0.4],
    [48.180626, 11.553809, 0.4],
    
    // English Garden area - Ring around the park
    // Western edge (Schwabing/Leopoldstraße)
    [48.158843, 11.582024, 0.8],
    [48.156843, 11.581024, 0.7],
    [48.154843, 11.580024, 0.7],
    [48.152843, 11.579024, 0.6],
    // Southern edge (near Prinzregentenstraße)
    [48.145580, 11.586766, 0.8],
    [48.144580, 11.588766, 0.7],
    [48.143580, 11.590766, 0.7],
    [48.142580, 11.592766, 0.6],
    // Eastern edge (Bogenhausen)
    [48.152580, 11.602766, 0.8],
    [48.154580, 11.603766, 0.7],
    [48.156580, 11.604766, 0.7],
    [48.158580, 11.605766, 0.6],
    // Northern edge (near Tivolistraße)
    [48.162580, 11.591766, 0.8],
    [48.161580, 11.589766, 0.7],
    [48.160580, 11.587766, 0.7],
    [48.159580, 11.585766, 0.6],
    
    // Hauptbahnhof area - New high intensity zone
    [48.140276, 11.558404, 0.9],
    [48.141276, 11.559404, 0.85],
    [48.139276, 11.557404, 0.85],
    [48.142276, 11.560404, 0.8],
    [48.138276, 11.556404, 0.8],
    // Wide area coverage
    [48.143276, 11.561404, 0.6],
    [48.137276, 11.555404, 0.6],
    [48.140276, 11.562404, 0.5],
    [48.144276, 11.559404, 0.4],
    [48.136276, 11.557404, 0.4],
    
    // Theresienwiese area - New medium-high intensity
    [48.131935, 11.547561, 0.8],
    [48.132935, 11.548561, 0.75],
    [48.130935, 11.546561, 0.75],
    [48.133935, 11.549561, 0.7],
    [48.129935, 11.545561, 0.7],
    // Wide area coverage
    [48.134935, 11.550561, 0.5],
    [48.128935, 11.544561, 0.5],
    [48.131935, 11.551561, 0.4],
    [48.135935, 11.548561, 0.3],
    [48.127935, 11.546561, 0.3],
    
    // Allianz Arena area - High intensity zone
    [48.218684, 11.624540, 0.9], // Center point
    [48.219684, 11.625540, 0.85],
    [48.217684, 11.623540, 0.85],
    [48.218684, 11.625540, 0.8],
    [48.219684, 11.624540, 0.8],
    [48.217684, 11.624540, 0.8],
    [48.218684, 11.623540, 0.8],
    // Wide area coverage
    [48.220684, 11.626540, 0.6],
    [48.216684, 11.622540, 0.6],
    [48.218684, 11.626540, 0.5],
    [48.221684, 11.625540, 0.5],
    [48.215684, 11.623540, 0.5],
    [48.218684, 11.627540, 0.4],
    [48.222684, 11.624540, 0.3],
    [48.214684, 11.624540, 0.3],

    // Ostbahnhof area - Major transport hub
    [48.127545, 11.604728, 0.85],
    [48.128545, 11.605728, 0.8],
    [48.126545, 11.603728, 0.8],
    [48.127545, 11.606728, 0.7],
    [48.125545, 11.604728, 0.7],

    // Sendlinger Tor area - Shopping and transit hub
    [48.133234, 11.567026, 0.85],
    [48.134234, 11.568026, 0.8],
    [48.132234, 11.566026, 0.8],
    [48.133234, 11.569026, 0.7],
    [48.131234, 11.567026, 0.7],

    // Maxvorstadt/University area
    [48.150837, 11.576630, 0.8],
    [48.151837, 11.577630, 0.75],
    [48.149837, 11.575630, 0.75],
    [48.152837, 11.578630, 0.7],
    [48.148837, 11.574630, 0.7],

    // Schwabing entertainment district
    [48.161837, 11.576630, 0.85],
    [48.162837, 11.577630, 0.8],
    [48.160837, 11.575630, 0.8],
    [48.163837, 11.578630, 0.7],
    [48.159837, 11.574630, 0.7],

    // BMW Welt/Museum area
    [48.177015, 11.559799, 0.85],
    [48.178015, 11.560799, 0.8],
    [48.176015, 11.558799, 0.8],
    [48.179015, 11.561799, 0.7],
    [48.175015, 11.557799, 0.7],

    // Westend residential area
    [48.137234, 11.530026, 0.7],
    [48.138234, 11.531026, 0.65],
    [48.136234, 11.529026, 0.65],
    [48.139234, 11.532026, 0.6],
    [48.135234, 11.528026, 0.6],

    // Giesing residential/commercial mix
    [48.115234, 11.588026, 0.75],
    [48.116234, 11.589026, 0.7],
    [48.114234, 11.587026, 0.7],
    [48.117234, 11.590026, 0.65],
    [48.113234, 11.586026, 0.65],

    // Moosach area
    [48.183234, 11.508026, 0.7],
    [48.184234, 11.509026, 0.65],
    [48.182234, 11.507026, 0.65],
    [48.185234, 11.510026, 0.6],
    [48.181234, 11.506026, 0.6],

    // Pasing station area
    [48.148234, 11.461026, 0.8],
    [48.149234, 11.462026, 0.75],
    [48.147234, 11.460026, 0.75],
    [48.150234, 11.463026, 0.7],
    [48.146234, 11.459026, 0.7],

    // Garching research campus
    [48.265837, 11.671630, 0.75],
    [48.266837, 11.672630, 0.7],
    [48.264837, 11.670630, 0.7],
    [48.267837, 11.673630, 0.65],
    [48.263837, 11.669630, 0.65],

    // Neue Messe München / Trade Fair Center
    [48.134837, 11.693630, 0.85], // Main entrance
    [48.135837, 11.694630, 0.8],
    [48.133837, 11.692630, 0.8],
    [48.136837, 11.695630, 0.7],
    [48.132837, 11.691630, 0.7],

    // Hirschgarten area - Popular beer garden & residential
    [48.143234, 11.520026, 0.75],
    [48.144234, 11.521026, 0.7],
    [48.142234, 11.519026, 0.7],
    [48.145234, 11.522026, 0.65],
    [48.141234, 11.518026, 0.65],

    // Münchner Freiheit - Shopping & Transit Hub
    [48.161234, 11.586026, 0.85],
    [48.162234, 11.587026, 0.8],
    [48.160234, 11.585026, 0.8],
    [48.163234, 11.588026, 0.7],
    [48.159234, 11.584026, 0.7],

    // Rotkreuzplatz area
    [48.154234, 11.512026, 0.75],
    [48.155234, 11.513026, 0.7],
    [48.153234, 11.511026, 0.7],
    [48.156234, 11.514026, 0.65],
    [48.152234, 11.510026, 0.65],

    // Tierpark Hellabrunn (Zoo)
    [48.100234, 11.555026, 0.8],
    [48.101234, 11.556026, 0.75],
    [48.099234, 11.554026, 0.75],
    [48.102234, 11.557026, 0.7],
    [48.098234, 11.553026, 0.7],

    // Klinikum Großhadern
    [48.110234, 11.477026, 0.8],
    [48.111234, 11.478026, 0.75],
    [48.109234, 11.476026, 0.75],
    [48.112234, 11.479026, 0.7],
    [48.108234, 11.475026, 0.7],

    // Arabella Park business district
    [48.151234, 11.621026, 0.85],
    [48.152234, 11.622026, 0.8],
    [48.150234, 11.620026, 0.8],
    [48.153234, 11.623026, 0.7],
    [48.149234, 11.619026, 0.7],

    // Neuperlach Zentrum
    [48.104234, 11.641026, 0.8],
    [48.105234, 11.642026, 0.75],
    [48.103234, 11.640026, 0.75],
    [48.106234, 11.643026, 0.7],
    [48.102234, 11.639026, 0.7],

    // TUM Campus Garching (expanded)
    [48.268234, 11.671026, 0.85],
    [48.269234, 11.672026, 0.8],
    [48.267234, 11.670026, 0.8],
    [48.270234, 11.673026, 0.7],
    [48.266234, 11.669026, 0.7],

    // Karlsplatz (Stachus)
    [48.139234, 11.565026, 0.9],
    [48.140234, 11.566026, 0.85],
    [48.138234, 11.564026, 0.85],
    [48.141234, 11.567026, 0.8],
    [48.137234, 11.563026, 0.8],

    // Odeonsplatz area
    [48.142234, 11.578026, 0.85],
    [48.143234, 11.579026, 0.8],
    [48.141234, 11.577026, 0.8],
    [48.144234, 11.580026, 0.7],
    [48.140234, 11.576026, 0.7],

    // Viktualienmarkt
    [48.135234, 11.576026, 0.85],
    [48.136234, 11.577026, 0.8],
    [48.134234, 11.575026, 0.8],
    [48.137234, 11.578026, 0.7],
    [48.133234, 11.574026, 0.7],

    // Flughafen München Franz Josef Strauß
    [48.353234, 11.786026, 0.95], // Terminal 1
    [48.354234, 11.787026, 0.9],
    [48.352234, 11.785026, 0.9],
    [48.355234, 11.788026, 0.85],
    [48.351234, 11.784026, 0.85],
    [48.357234, 11.790026, 0.8], // Terminal 2
    [48.358234, 11.791026, 0.75],
    [48.356234, 11.789026, 0.75],
    [48.359234, 11.792026, 0.7],
    [48.355234, 11.788026, 0.7],

    // Leuchtenbergring
    [48.133234, 11.607026, 0.75],
    [48.134234, 11.608026, 0.7],
    [48.132234, 11.606026, 0.7],
    [48.135234, 11.609026, 0.65],
    [48.131234, 11.605026, 0.65]
];

const heatLayer = L.heatLayer(HEATMAP_POINTS, {
    radius: 35,
    blur: 25,
    maxZoom: 15,
    gradient: {
        0.2: '#87CEEB',  // Light blue
        0.4: '#4CAF50',  // Green
        0.6: '#FFC107',  // Yellow
        0.8: '#FF5722',  // Orange
        1.0: '#E20074'   // T-Mobile magenta
    }
}).addTo(map);
</script>
{% endblock %}